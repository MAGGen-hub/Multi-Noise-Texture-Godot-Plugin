@tool
@icon("MultiNoiseTexture2D.svg")
## A 2D RGBA texture with each color channel filled with noise generated by Noise object.
##
## When programming shaders, sometimes you need to use 2 or even more [NoiseTexture2D] uniforms.[br]
## Adding more than 3 [code]uniform sampler2D noise[/code] into shader makes it a litle bit hard to edit.[br]
## This class designed to combine noise from four [FastNoiseLite] objects into one texture.
class_name MultiNoiseTexture2D extends ImageTexture
#region ToolInterface
## [b]WARNING:[/b] 4096x4096 2d texture has 300+ (400+ with mipmaps) Mb weight![br]
## Setting this parameter to higer values may cost you [code]EXTRA[/code] memory![br]
## Also it may cause [code]SERIOUS[/code] errors and performance issues![br]
## Try to avoid setting this to higer values at [code]ALL[/code] costs!
const blocator = 4096
## Created because of ImageTexture2D Inspector updation bug.[br][br]
## If [code]true[/code], updates texture each time one of [FastNoiseLite]s was changed.[br][br]
## [b]Warning:[/b] Enabling this will reset inspector each time [FastNoiseLite] was edited!
@export var auto_update := false
## Works like button - Recreates image [br][br]
## [b]Note:[/b] Usefull when auto_update disabled.
@export var update := false:
	set(value):
		update_required = true
		execute_thread()
## Width of generated texture (in pixels).
@export var width := 512:
	set(value): 
		value = clamp(1,value,blocator)
		width=value; update_required = true; execute_thread()
## Heigth of generated texture (in pixels).
@export var heigth := 512:
	set(value): 
		value = clamp(1,value,blocator)
		heigth=value; update_required = true; execute_thread()
## If [code]true[/code], inverts the noise textue. White becomes black, black becomse white.
@export var invert := false:
	set(value): invert=value; update_required = true; execute_thread()
## Determines whether the noise image is calculated in 3D space. May result in reduced contrast.
@export var in_3d_space := false:
	set(value): in_3d_space=value; update_required = true; execute_thread()
## Determines whether mipmaps are generated for this texture. Enabling this results in less texture aliasing in the distance,
## at the cost of increasing memory usage by roughly 33% and making the noise texture generation take longer.[br][br]
## [b]Note:[/b] [member generate_mipmaps] requires mipmap filtering to be enabled on the material using the [NoiseTexture2D] to have an effect.
@export var generate_mipmaps := true:
	set(value): generate_mipmaps=value; update_required = true; execute_thread()
## If [code]true[/code], a seamless texture is requested from the [Noise] resource.[br][br]
## [b]Note:[/b] Seamless noise textures may take longer to generate and/or can have a lower contrast compared to non-seamless noise depending on the used [Noise] resource. This is because some implementations use higher dimensions for generating seamless noise.[br][br]
## [b]Note:[/b] The default [FastNoiseLite] implementation uses the fallback path for seamless generation. If using a [member width] or [member height] lower than the default, you may need to increase [member seamless_blend_skirt] to make seamless blending more effective.
@export var seamless := false:
	set(value): seamless=value; update_required = true; execute_thread()
## Used for the default/fallback implementation of the seamless texture generation. It determines the distance over which the seams are blended. High values may result in less details and contrast. See [Noise] for further details.[br][br]
## [b]Note:[/b] If using a [member width] or [member height] lower than the default, you may need to increase [member seamless_blend_skirt] to make seamless blending more effective.
@export_range(0,1,0.001) var seamless_blend_skirt := 0.1:
	set(value): seamless_blend_skirt=value; update_required = true; execute_thread()
## I don't think that turning THIS kind of image into normal map is posible...
#@export var as_normal_map=false:
	#set(value): as_normal_map=value; update_texture()
## If [code]true[/code], the noise image coming from the noise generator is normalized to the range 0.0 to 1.0.[br][br]
## Turning normalization off can affect the contrast and allows you to generate non repeating tileable noise textures.
@export var normalize :=true:
	set(value): normalize=value; update_required = true; execute_thread()
## The instance of the [Noise] object that used as [code]Red[/code] component of final texture.
@export var Noise_R:Noise:
	set(value): 
		Noise_R=value
		if value: value.connect("changed",func(): if auto_update: update_required = true; execute_thread())
		update_required = true
		execute_thread()
## The instance of the [Noise] object that used as [code]Green[/code] component of final texture.
@export var Noise_G:Noise:
	set(value): 
		Noise_G=value
		if value:
			value.seed=1
			value.connect("changed",func(): if auto_update: update_required = true; execute_thread())
		update_required = true
		execute_thread()
## The instance of the [Noise] object that used as [code]Blue[/code] component of final texture.
@export var Noise_B:Noise:
	set(value): 
		Noise_B=value
		if value:
			value.seed=2
			value.connect("changed",func(): if auto_update: update_required = true; execute_thread())
		update_required = true
		execute_thread()
## The instance of the [Noise] object that used as [code]Alpha[/code] component of final texture.
@export var Noise_A:Noise:
	set(value): 
		Noise_A=value
		if value:
			value.seed=3
			value.connect("changed",func(): if auto_update: update_required = true; execute_thread())
		update_required = true
		execute_thread()
## If [code]true[/code], prints mesage each time generator thread was started/finished. 
#@export var warnings := false
## Some kind of logger for editor that displays progress of texture generation.
@export var progress = "Finished"
#endregion

#region TextureBuild
# Changable variables
## Signal that launched after thread was finished
signal thread_finished
## Determines if texture regeneration required
var update_required := false
## Generator thread
var thread: Thread
## Dictionary with "read_only" that can be used by thread. To avoid mutex spaming
var thread_data:Dictionary = {}
## Image generated by thread
var generated_image: Image

func _validate_property(property):
	if property.name=="seamless_blend_skirt" and not seamless:
		property.usage = PROPERTY_USAGE_NO_EDITOR
	if property.name=="progress":
		property.usage = PROPERTY_USAGE_READ_ONLY | PROPERTY_USAGE_EDITOR
func _init():
	connect("thread_finished",finish_thread)
	execute_thread()

## Function to prepare thread launch
func execute_thread():
	# detect launched thread and avoid forced thread relaunching
	if thread:
		if thread.is_alive(): return
		if thread.is_started(): thread.wait_to_finish()
	# "read_only" dictionary to avoid mutex spamming
	thread_data = {
		Noise_R = Noise_R.duplicate() if Noise_R else null,
		Noise_G = Noise_G.duplicate() if Noise_G else null,
		Noise_B = Noise_B.duplicate() if Noise_B else null,
		Noise_A = Noise_A.duplicate() if Noise_A else null,
		width = width, heigth = heigth, invert = invert, in_3d_space = in_3d_space,
		seamless = seamless, seamless_blend_skirt = seamless_blend_skirt, normalize = normalize,
		mipmaps = generate_mipmaps}
	# launch thread
	#if warnings: print("MultiNoiseTexture2D ",get_rid(),": Generation started...")#time=Time.get_ticks_usec() #was here for optimisation
	thread = Thread.new()
	thread.start(generator_thread)
	update_required=false

## Texture generator thread
func generator_thread():
	## If any of noises equal to null -> return placeholder
	var placeholder = Image.create(thread_data.width,thread_data.heigth,false,Image.FORMAT_L8).data.data
	var get_noise_image = func(noise : Noise):
		if not noise: return placeholder
		if thread_data.seamless:return noise.get_seamless_image(thread_data.width,thread_data.heigth,thread_data.invert,thread_data.in_3d_space,thread_data.seamless_blend_skirt,thread_data.normalize).data.data
		return noise.get_image(thread_data.width,thread_data.heigth,thread_data.invert,thread_data.in_3d_space,thread_data.normalize).data.data
	## Load all noise images from FastNoiseLite objects
	progress = "Load:0/4" # Load images from noise
	var R = get_noise_image.call(thread_data.Noise_R); progress = "Load:1/4"
	var G = get_noise_image.call(thread_data.Noise_G); progress = "Load:2/4"
	var B = get_noise_image.call(thread_data.Noise_B); progress = "Load:3/4"
	var A = get_noise_image.call(thread_data.Noise_A); progress = "Load:4/4"
	## Start multi texture generation
	var size = thread_data.width*thread_data.heigth
	var data: PackedByteArray = [];data.resize(size*4)
	for i in size:
		data[i*4  ]=R[i]
		data[i*4+1]=G[i]
		data[i*4+2]=B[i]
		data[i*4+3]=A[i]
		progress=str("Gen: ",i*100/size,"%")
	##Save image to special variable to set it later (to minimise influence of Inspector updation bug)
	generated_image = Image.create_from_data(thread_data.width,thread_data.heigth,false,Image.FORMAT_RGBA8,data)
	if thread_data.mipmaps: generated_image.generate_mipmaps()
	## Finalise and tell main thread that generation proccess was finished
	progress = "Finished"
	call_deferred("emit_signal","thread_finished")
	OS.delay_msec(50)#half_second_delay

## Function to finish thread after completion
func finish_thread():
	if thread.is_started(): thread.wait_to_finish()
	#if warnings: print("MultiNoiseTexture2D ",get_rid(),": Generation finished.")#print(Time.get_ticks_usec() - time) #was here for optimisation
	if update_required: execute_thread()
	else:
		set_image(generated_image)
		emit_changed()
#endregion
