@tool
@icon("MultiNoiseTexture3D.svg")
## A 3D RGBA texture with each color channel filled with noise generated by Noise object.
##
## When programming shaders, sometimes you need to use 2 or even more [NoiseTexture3D] uniforms.[br]
## Adding more than 3 [code]uniform sampler3D noise[/code] into shader makes it a litle bit hard to edit.[br]
## This class designed to combine noise from four [FastNoiseLite] objects into one texture.
class_name MultiNoiseTexture3D extends ImageTexture3D
#region ToolInterface
## [b]WARNING:[/b] 256x256x256 3d texture has 300+ Mb weight![br]
## Setting this parameter to higher values may cost you [code]EXTRA[/code] memory![br]
## Also it may cause [code]SERIOUS[/code] errors and performance issues![br]
## Try to avoid setting this to higher values at [code]ALL[/code] costs!
const blocator = 256
### Works like button - Recreates image [br][br]
### [b]Note:[/b] Usefull when auto_update disabled.
#@export var update := false:
	#set(value):
		#update_required = true
		#execute_thread()
## Width of generated texture (in pixels).
@export var width := 64:
	set(value): 
		value = clamp(1,value,blocator)
		width=value; update_required = true; execute_thread()
## Heigth of generated texture (in pixels).
@export var heigth := 64:
	set(value):
		value = clamp(1,value,blocator)
		heigth=value; update_required = true; execute_thread()
## Depth of generated texture (in pixels).
@export var depth := 64:
	set(value): 
		value = clamp(1,value,blocator)
		depth=value; update_required = true; execute_thread()
## If [code]true[/code], inverts the noise textue. White becomes black, black becomse white.
@export var invert := false:
	set(value): invert=value; update_required = true; execute_thread()
## If [code]true[/code], a seamless texture is requested from the [Noise] resource.[br][br]
## [b]Note:[/b] Seamless noise textures may take longer to generate and/or can have a lower contrast compared to non-seamless noise depending on the used [Noise] resource. This is because some implementations use higher dimensions for generating seamless noise.[br][br]
## [b]Note:[/b] The default [FastNoiseLite] implementation uses the fallback path for seamless generation. If using a [member width] or [member height] lower than the default, you may need to increase [member seamless_blend_skirt] to make seamless blending more effective.
@export var seamless := false:
	set(value): seamless=value; update_required = true; execute_thread()
## Used for the default/fallback implementation of the seamless texture generation. It determines the distance over which the seams are blended. High values may result in less details and contrast. See [Noise] for further details.[br][br]
## [b]Note:[/b] If using a [member width] or [member height] lower than the default, you may need to increase [member seamless_blend_skirt] to make seamless blending more effective.
@export_range(0,1,0.001) var seamless_blend_skirt := 0.1:
	set(value): seamless_blend_skirt=value; update_required = true; execute_thread()
## I don't think that turning THIS kind of image into normal map is posible...
#@export var as_normal_map=false:
	#set(value): as_normal_map=value; update_texture()
## If [code]true[/code], the noise image coming from the noise generator is normalized to the range 0.0 to 1.0.[br][br]
## Turning normalization off can affect the contrast and allows you to generate non repeating tileable noise textures.
@export var normalize :=true:
	set(value): normalize=value; update_required = true; execute_thread()
## The instance of the [Noise] object that used as [code]Red[/code] component of final texture.
@export var Noise_R:Noise:
	set(value): 
		Noise_R=value
		if value: value.connect("changed",func(): update_required = true; execute_thread())
		update_required = true
		execute_thread()
## The instance of the [Noise] object that used as [code]Green[/code] component of final texture.
@export var Noise_G:Noise:
	set(value): 
		Noise_G=value
		if value:
			value.seed=1
			value.connect("changed",func(): update_required = true; execute_thread())
		update_required = true
		execute_thread()
## The instance of the [Noise] object that used as [code]Blue[/code] component of final texture.
@export var Noise_B:Noise:
	set(value): 
		Noise_B=value
		if value:
			value.seed=2
			value.connect("changed",func(): update_required = true; execute_thread())
		update_required = true
		execute_thread()
## The instance of the [Noise] object that used as [code]Alpha[/code] component of final texture.
@export var Noise_A:Noise:
	set(value): 
		Noise_A=value
		if value:
			value.seed=3
			value.connect("changed",func(): update_required = true; execute_thread())
		update_required = true
		execute_thread()
## If [code]true[/code], prints mesage each time generator thread was started/finished. 
#@export var warnings := false
## Some kind of logger for editor that displays progress of texture generation.
@export var progress = "Finished"
#endregion

#region TextureBuild
# Changable variables
## Signal that launched after thread was finished
signal thread_finished
## Determines if texture regeneration required
var update_required := false
## Generator thread
var thread: Thread
## Dictionary with "read_only" that can be used by thread. To avoid mutex spaming
var thread_data := {}

func _validate_property(property):
	if property.name=="seamless_blend_skirt" and not seamless:
		property.usage = PROPERTY_USAGE_NO_EDITOR
	if property.name=="progress":
		property.usage = PROPERTY_USAGE_READ_ONLY | PROPERTY_USAGE_EDITOR
func _init():
	connect("thread_finished",finish_thread)
	execute_thread()

## Function to prepare thread launch
func execute_thread():	# detect launched thread and avoid forced thread relaunching
	if thread:
		if thread.is_alive(): return
		if thread.is_started(): thread.wait_to_finish()
	# "read_only" dictionary to avoid mutex spamming
	thread_data = {
		Noise_R = Noise_R.duplicate() if Noise_R else null,
		Noise_G = Noise_G.duplicate() if Noise_G else null,
		Noise_B = Noise_B.duplicate() if Noise_B else null,
		Noise_A = Noise_A.duplicate() if Noise_A else null,
		width = width, heigth = heigth, depth = depth, invert = invert,
		seamless = seamless, seamless_blend_skirt = seamless_blend_skirt, normalize = normalize}
	# launch thread
	#if warnings: print("MultiNoiseTexture2D ",get_rid(),": Generation started...")#time=Time.get_ticks_usec() #was here for optimisation
	thread = Thread.new()
	thread.start(generator_thread)
	update_required=false

## Texture generator thread
func generator_thread():
	## If any of noises equal to null -> return placeholderArray
	var placeholder=Image.create(thread_data.width,thread_data.heigth,false,Image.FORMAT_L8)
	var placeholderArray = []; placeholderArray.resize(thread_data.depth); placeholderArray.fill(placeholder)
	var get_noise_image = func(noise:Noise):
		if not noise: return placeholderArray
		if thread_data.seamless:return noise.get_seamless_image_3d(thread_data.width,thread_data.heigth,thread_data.depth,thread_data.invert,thread_data.seamless_blend_skirt,thread_data.normalize)
		return noise.get_image_3d(thread_data.width,thread_data.heigth,thread_data.depth,thread_data.invert,thread_data.normalize)
	## Load all noise images from FastNoiseLite objects
	progress = "Load:0/4" # Load images from noise
	var R_arr = get_noise_image.call(thread_data.Noise_R); progress = "Load:1/4"
	var G_arr = get_noise_image.call(thread_data.Noise_G); progress = "Load:2/4"
	var B_arr = get_noise_image.call(thread_data.Noise_B); progress = "Load:3/4"
	var A_arr = get_noise_image.call(thread_data.Noise_A); progress = "Load:4/4"#Done
	## Start multi texture generation
	var dataArray : Array[Image] = [];dataArray.resize(thread_data.depth)
	for j in thread_data.depth:
		var R = R_arr[j].data.data
		var G = G_arr[j].data.data
		var B = B_arr[j].data.data
		var A = A_arr[j].data.data
		var size = thread_data.width*thread_data.heigth
		var data: PackedByteArray = []; data.resize(size*4)
		for i in size:
			data[i*4  ]=R[i]
			data[i*4+1]=G[i]
			data[i*4+2]=B[i]
			data[i*4+3]=A[i]
		dataArray[j] = Image.create_from_data(thread_data.width,thread_data.heigth,false,Image.FORMAT_RGBA8,data)
		progress=str("Gen:",j,"/",dataArray.size())#generate textures
	## ImageTexture3D has no bug with Inspector dock updation, so image can be generated without tricks and fixes
	call_deferred("create",Image.FORMAT_RGBA8,thread_data.width,thread_data.heigth,thread_data.depth,false,dataArray)
	## Finalise and tell main thread that generation proccess was finished
	progress="Finished"
	call_deferred("emit_signal","thread_finished")
	OS.delay_msec(50)#half_second_delay

## Function to finish thread after completion
func finish_thread():
	if thread.is_started(): thread.wait_to_finish()
	emit_changed()
	#if warnings: print("MultiNoiseTexture2D ",get_rid(),": Generation finished.")#print(Time.get_ticks_usec() - time) #was here for optimisation
	if update_required: execute_thread()
#endregion
